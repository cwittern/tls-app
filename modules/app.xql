xquery version "3.1";

module namespace app="http://hxwd.org/app";

declare namespace tei= "http://www.tei-c.org/ns/1.0";
declare namespace tls="http://hxwd.org/ns/1.0";

import module namespace templates="http://exist-db.org/xquery/templates" ;
import module namespace config="http://hxwd.org/config" at "config.xqm";
import module namespace kwic="http://exist-db.org/xquery/kwic"
    at "resource:org/exist/xquery/lib/kwic.xql";
import module namespace tlslib="http://hxwd.org/lib" at "tlslib.xql";

declare variable $app:SESSION := "tls:results";

declare variable $app:lmap := map{
"zh" : "Modern Chinese",
"och" : "Old Chinese",
"syn-func" : "Syntactic Functions",
"sem-feat" : "Semantic Features",
"word" : "Words",
"char" : "Chars",
"concept" : "Concepts",
"definition" : "Definition",
"notes" : "Notes",
"old-chinese-criteria" : "Old Chinese Criteria",
"modern-chinese-criteria" : "Modern Chinese Criteria",
"taxonymy" : "Taxonoymy",
"antonymy" : "Antonymy",
"see" : "See also",
"source-references" : "Bibliography",
"warring-states-currency" : "Warring States Currency",
"register" : "Register"
};

(:~
 : This is a sample templating function. It will be called by the templating module if
 : it encounters an HTML element with an attribute: data-template="app:test" or class="app:test" (deprecated). 
 : The function has to take 2 default parameters. Additional parameters are automatically mapped to
 : any matching request or function parameter.
 : 
 : @param $node the HTML node with the attribute which triggered this call
 : @param $model a map containing arbitrary data - used to pass information between template calls
 :)
declare function app:test($node as node(), $model as map(*)) {
    <p>Dummy template output generated by function app:test at {current-dateTime()}. The templating
        function was triggered by the data-template attribute <code>data-template="app:test"</code>.</p>
};

(: start here :)
(:~
 : Get app logo. Value passed from repo-config.xml  
:)
declare
    %templates:wrap
function app:logo($node as node(), $model as map(*)) {
    if($config:get-config//repo:logo != '') then
        <img class="app-logo img-fluid" src="{$config:nav-base || '/resources/images/' || $config:get-config//repo:logo/text() }" title="{$config:app-title}"/>
    else ()
};



declare function app:tls-summary($node as node(), $model as map(*)) {
(:let $tlsroot := $config:tls-data-root :)
<div>
{let $tlsroot := $config:tls-data-root
return
<p>
Dummy template {local-name($node), string($node), string($tlsroot), count(collection($tlsroot)//*:head)}
<table>
{for $a in collection($tlsroot)//tei:head
group by $key := $a/ancestor::tei:div/@type
order by $key
return
  <tr>
  <td>Key: {data($key)}</td>
  <td>Count: {count($a)}</td>
</tr>
}
</table>
</p>}
</div>
};

(: browse :)

declare 
    %templates:wrap
function app:browse($node as node()*, $model as map(*), $type as xs:string?, $filter as xs:string?)
{
    session:create(),
    let $filterString := if (string-length($filter) > 0) then $filter else ""    
    let $hits := if (("concept", "syn-func", "sem-feat") = $type) 
      then app:do-browse($type, $filterString)
      else if ($type = "word") then app:browse-word($type, $filterString)
      else if ($type = "char") then app:browse-char($type, $filterString)
      else ()
    let $store := session:set-attribute("tls-browse", $hits)
    return
  <div class="card">
    <div class="card-header" id="{$type}-card">
      <div class="row mb-0">
      <span class="col-3"><h4>{map:get($app:lmap, $type)}</h4></span>&#160;
      <span class="col-3">
      <input class="form-control" id="myInput" type="text" placeholder="Type to filter..."/>
      </span>
      </div>
    </div>
    <div class="card-body"><table class="table">
    <thead><tr>
    <th scope="col">Abbreviation</th>
    <th scope="col">Definition</th>
    <th scope="col">Remarks</th>    
    </tr></thead><tbody class="table-striped">{
    for $h in $hits
    let $n := $h/tei:head/text(),
    $id := $h/@xml:id,
    $def := $h/tei:p
    order by $n
    return
    <tr id="{$id}" class="abbr">
    <td class="abbxr"><a href="concept.html?uuid={$id}">{$n}</a></td>
    <td>{$def}</td>
    <td></td>
    </tr>

    }</tbody></table></div>
  </div>
    
(:       map:entry("browse", $hits):)
};

(: :)
declare function app:browse-word($type as xs:string?, $filter as xs:string?)
{
    let $typeString := if (string-length($type) > 0) then $type else "word"    
    for $hit in collection($config:tls-data-root)//tei:entry[@type=$type]
    let $head := $hit/tei:orth
    order by $head
    return $hit
};

(: taxchar if available, otherwise look for words? :)
declare function app:browse-char($type as xs:string?, $filter as xs:string?)
{
    for $hit in collection($config:tls-data-root)//tei:div[@type=$type]
    return $hit
};

declare function app:do-browse($type as xs:string?, $filter as xs:string?)
{
    for $hit in collection($config:tls-data-root)//tei:div[@type=$type]
    let $head := data($hit/tei:head)
    where starts-with($head, $filter)
    order by $head
    return $hit
};



(: search related functions :)

declare 
    %templates:wrap
function app:query($node as node()*, $model as map(*), $query as xs:string?, $mode as xs:string?)
{
    session:create(),
    let $hits := app:do-query($query, $mode)
    let $store := session:set-attribute($app:SESSION, $hits)
    return
       map:entry("hits", $hits)
};

declare function app:do-query($queryStr as xs:string?, $mode as xs:string?)
{
    let $dataroot := ("/db/apps/tls-texts", "/db/apps/tls-data")
    let $query := app:create-query(lower-case($queryStr), $mode)
    for $hit in collection($dataroot)//tei:div[ft:query(., $query)]
    order by ft:score($hit) descending
    return $hit
};

declare function app:ngram-query($queryStr as xs:string?, $mode as xs:string?)
{
    let $dataroot := ("/db/apps/tls-texts", "/db/apps/tls-data")
    for $hit in collection($dataroot)//tei:seg[ngram:contains(., $queryStr)]
    return $hit 
};



declare
    %templates:wrap
function app:from-session($node as node()*, $model as map(*)) {
    map:entry("hits", session:get-attribute($app:SESSION))
};



declare function app:create-query($queryStr as xs:string?, $mode as xs:string?)
{
<query>
    {
    if ($mode eq 'any') then 
        for $term in tokenize($queryStr, '\s')
        return
        <term occur="should">{$term}</term>
    else if ($mode eq 'all') then
        for $term in tokenize($queryStr, '\s')
        return
        <term occur="must">{$term}</term>
    else if ($mode eq 'phrase') then
        <phrase>{$queryStr}</phrase>
    else 
        <near>{$queryStr}</near>
    }
</query>
};

declare 
    %templates:default("start", 1)
    function app:show-hits($node as node()*, $model as map(*),$start as xs:int)
{
    for $hit at $p in subsequence($model("hits"), $start, 10)
    let $kwic := kwic:summarize($hit, <config width="40" table="yes"/>, app:filter#2)
    return
    <div class="tls-concept" xmlns="http://www.w3.org/1999/xhtml">
      <h3>{$hit/ancestor::tei:head/text()}</h3>
      <span class="number">{$start + $p - 1}</span>
      <table>{ $kwic }</table>
    </div>
};    


(:

declare
    %templates:default("start", 1)
    %templates:default("length", 10)
    function app:show-hits($node as node()*, $model as map()*,$start as xs:int, $length as xs:int)
{
    for $hit at $p in subsequence($model("hits"), $start, $length)
    let $kwic := kwic:summarize($hit, <config width="40" table="yes"/>, app:filter#2)
    return
    <div class="tls-concept" xmlns="http://www.w3.org/1999/xhtml">
      <h3>{$hit/ancestor::tei:head/text()}</h3>
      <span class="number">{$start + $p - 1}</span>
      <table>{ $kwic }</table>
    </div>
};
:)
declare %private function app:filter($node as node(), $mode as xs:string?) as text()?
{
    if ($mode eq 'before') then 
    text {concat($node, ' ') }
    else 
    text {concat(' ', $node) }
};

(: temporarily added the search code here to see if the search is working at all
 this should just be count($model("hits"))
:)
declare
    %templates:wrap
function app:hit-count($node as node()*, $model as map(*), $query as xs:string?) {
   count($model("hits"))
};

(: textview related functions :)

(: function textview 
@param location  text location or text id for the text to display. If empty, display text list
@param mode      for textlist: 'tls' texts or 'chant' texts or 'all' texts
:)
declare 
    %templates:wrap
    %templates:default("prec", 0)
    %templates:default("foll", 50)     
function app:textview($node as node()*, $model as map(*), $location as xs:string?, $mode as xs:string?, $prec as xs:int?, $foll as xs:int?)
{
    let $dataroot := $config:tls-data-root
    return
    (session:create(),
    if (string-length($location) > 0) then
     if (contains($location, '_')) then
      let $textid := tokenize($location, '_')[1]
      let $firstseg := collection($config:tls-texts-root)//tei:*[@xml:id=$location]
      return
        tlslib:displaychunk($firstseg, $prec, $foll)
     else
      let $firstdiv := (collection($config:tls-texts-root)//tei:*[@xml:id=$location]//tei:body/tei:div[1])
      let $targetseg := ($firstdiv//tei:seg)[1]
      return
       tlslib:displaychunk($targetseg, $prec, $foll)
    else 
    let $titles := for $t in collection(concat($config:tls-texts-root, '/tls'))//tei:titleStmt/tei:title
            let $textid := data($t/ancestor::tei:TEI/@xml:id)
            where not (contains($textid, "-en"))
            return $t
    return
    <div>
    <h1>Available annotated texts: ({count($titles)})</h1>
    <ul>
    {
    for $title in $titles
    let $textid := data($title/ancestor::tei:TEI/@xml:id)
    order by $textid
    return 
    <li><a href="?location={$textid}">{$textid, $title/text()}</a></li>
    }
    </ul>
    </div>
    )
};

(: taxchar display :)
declare 
    %templates:wrap
function app:char($node as node()*, $model as map(*), $char as xs:string?, $id as xs:string?)
{
    (session:create(),
    let $key := replace($id, '#', '')
    let $n := if (string-length($id) > 0) then
      doc(concat($config:tls-data-root, "/core/taxchar.xml"))//tei:div[@xml:id = $id]
    else
      doc(concat($config:tls-data-root, "/core/taxchar.xml"))//tei:div[tei:head[. = $char]]
    return
    <div class="card">
    <div class="card-body">
    <h4 class="card-title">{$n/tei:head/text()}</h4>
    </div>
    <div class="card-text">
{local:proc_char($n/tei:list)}
    </div>
    </div>
)};   
   
declare function local:proc_char($node as node())
{ 
typeswitch ($node)
  case element(tei:div) return
      <div>{for $n in $node/node() return local:proc_char($n)}</div>
  case element(tei:head) return
  <h4 class="card-title">{$node/text()}</h4>
  case element(tei:list) return
  <ul class="list-unstyled">{for $n in $node/node()
       return
       local:proc_char($n)
  }</ul>
  case element(tei:item) return
    <li>{for $n in $node/node()
        return
            local:proc_char($n)
    }</li>
  case element(tei:ref) return
     let $id := substring($node/@target, 2),
     $char := $node/ancestor::tei:div[1]/tei:head/text(),
     $swl := collection($config:tls-data-root)//tei:div[@xml:id=$id]//tei:entry[tei:form/tei:orth[. = $char]]//tei:sense
     return
      <span>
      <a href="concept.html?uuid={$id}" class="mr-2 ml-2">{$node/text()}</a>
      <button class="btn badge badge-light" type="button" 
      data-toggle="collapse" data-target="#{$id}-swl">{count($swl)}</button>
      <ul class="list-unstyled collapse" id="{$id}-swl"> 
      {for $sw in $swl
      return tlslib:display_sense($sw)}
      </ul>
      </span>
  case text() return
      $node
  default
  return 
  <not-handled>{$node}</not-handled>
};
   
   
   
(: concept display :)
declare 
    %templates:wrap
function app:concept($node as node()*, $model as map(*), $concept as xs:string?, $uuid as xs:string?)
{
    (session:create(),
    let $key := replace($uuid, '^#', '')
    let $c :=  if (string-length($key) > 0) then
       collection($config:tls-data-root || "/concepts")//tei:div[ends-with(@xml:id,$key)]    
     else
       collection($config:tls-data-root || "/concepts")//tei:div[tei:head[. = $concept]],
    $tr := $c//tei:list[@type="translations"]//tei:item
    return
    <div class="card">
    <div class="card-body">
    <h4 class="card-title">{$c/tei:head/text()}&#160;&#160;{for $t in $tr return 
      <span class="badge badge-light" title="{map:get($app:lmap, $t/@xml:lang)}">{$t/text()}</span>}</h4>
    <h5 class="card-subtitle" id="popover-test" data-toggle="popover">{$c/tei:div[@type="definition"]//tei:p/text()}</h5>
    <div id="concept-content" class="accordion">
    <div class="card">
    <div class="card-header" id="altnames-head">
      <h5 class="mb-0">
        <button class="btn" data-toggle="collapse" data-target="#altnames" >
          Alternate names
        </button>
      </h5>
      </div>
      <div id="altnames" class="collapse" data-parent="#concept-content">{for $i in $c//tei:list[@type="altnames"]/tei:item/text()
      return
      <span class="badge badge-pill badge-light">{$i}</span>
      }</div>
    </div>
    <!-- pointers -->
    <div class="card">
    <div class="card-header" id="pointers-head">
      <h5 class="mb-0">
        <button class="btn" data-toggle="collapse" data-target="#pointers" >
          Pointers
        </button>
      </h5>
      </div>
     <div id="pointers" class="collapse" data-parent="#concept-content">
     {for $p in $c//tei:div[@type="pointers"]//tei:list
     return
     (<h5 class="ml-2">{map:get($app:lmap, data($p/@type))}{tlslib:capitalize-first(data($p/@type/text()))}</h5>,
     <p>{for $r in $p//tei:ref return
     <span class="badge badge-light"><a href="concept.html?uuid={replace($r/@target, "#", "")}">{$r/text()}</a></span>
     }
     
     </p>)}
     </div>
    </div>
    <!-- notes -->
    <div class="card">
    <div class="card-header" id="notes-head">
      <h5 class="mb-0">
        <button class="btn" data-toggle="collapse" data-target="#notes" >
          Notes
        </button>
      </h5>
      </div>
     <div id="notes" class="collapse" data-parent="#concept-content">
     {for $d in $c//tei:div[@type="notes"]//tei:div
     return
     (<h5 class="ml-2">{map:get($app:lmap, data($d/@type))}</h5>,
     <div>{for $p in $d//tei:p return
     <p>{$p}</p>
     }     
     </div>)}
     </div>
    </div>
    <!-- bibl -->
    <div class="card">
    <div class="card-header" id="bibl-head">
      <h5 class="mb-0">
        <button class="btn" data-toggle="collapse" data-target="#bibl" >
          Source references
        </button>
      </h5>
      </div>
     <div id="bibl" class="collapse" data-parent="#concept-content">
     {for $d in $c//tei:div[@type="source-references"]//tei:bibl
     return
     $d
     }     
     </div>
    </div>
    
    <!-- -->
    </div>
    </div>
    <div id="word-content" class="card">
    <div class="card-body">
    <h4 class="card-title">Words</h4>
    <p class="card-text">
    {for $e in $c/tei:div[@type="words"]//tei:entry
    let $zi := $e/tei:form/tei:orth,
    $pr := $e/tei:form/tei:pron
    
    order by $zi[1]
(:    count $count :)
    return 
    <div><h5>{$zi/text()}&#160;&#160; {for $p in $pr return <span>{
    if (ends-with($p/@xml:lang, "oc")) then "OC: " else 
    if (ends-with($p/@xml:lang, "mc")) then "MC: " else (),
    $p/text()}&#160;</span>}</h5>
    <ul>{for $sw in $e//tei:sense
    return
    tlslib:display_sense($sw)
    }</ul>
    </div>
    }
    </p>
    </div>
    </div>
    </div>
    )
};


(: get words for new ann :)

declare 
    %templates:wrap
function app:get_sw($node as node()*, $model as map(*), $word as xs:string?)
{
for $w in tlslib:getwords($word, $model)
return $w
};

(: dialog functions :)
declare
    %templates:wrap
function app:swl-form-dialog($node as node()*, $model as map(*)){
<div id="swl-form" class="card ann-dialog overflow-auto">
<div class="card-body">
    <h5 class="card-title">New Attribution: <strong class="ml-2"><span id="swl-query-span">Word or char to annotate</span></strong>
     <button type="button" class="close" onclick="hide_swl_form()" aria-label="Close">
       &#215;
     </button>
</h5>
    <h6 class="text-muted">At:  <span id="swl-line-id-span" class="ml-2">Id of line</span></h6>
    <h6 class="text-muted">Line: <span id="swl-line-text-span" class="ml-2">Text of line</span></h6>
    <div class="card-text">
        <p><span class="badge badge-primary">Use</span> one of the following syntactic words (SW), 
        create a <span class="mb-2 badge badge-secondary">New SW</span> 
         or add a new concept to the word here: <span class="btn badge badge-light ml-2" data-toggle="modal" data-target="#new-concept">Concept</span> 
        <ul id="swl-select" class="list-unstyled"></ul>
        </p>
      </div>
    </div>    
    </div>
};

declare
    %templates:wrap
function app:add-concept-dialog($node as node()*, $model as map(*)){
<div id="new-concept" class="modal" tabindex="-1" role="dialog" style="display: none;">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Adding concept for <strong class="ml-2"><span id="concept-query-span">Word</span></strong>
                    <button class="btn badge badge-primary ml-2" type="button" onclick="get_guangyun()">
                        廣韻
                    </button>
                </h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    ×
                </button>
            </div>
            <div class="modal-body">
                <h6 class="text-muted">At:  <span id="concept-line-id-span" class="ml-2">Id of line</span></h6>
                <h6 class="text-muted">Line: <span id="concept-line-text-span" class="ml-2">Text of line</span></h6>
                <div>
                    <span id="concept-id-span" style="display:none;">UUID of selected concept</span>
                    <span id="synfunc-id-span" style="display:none;">UUID of selected syntactic funtion</span>
                    <span id="semfeat-id-span" style="display:none;">UUID of selected semantic feature</span>
                    
                </div>
                <div class="form-group" id="guangyun-group">
                    <span class="text-muted" id="guangyun-group-pl"> Press the 廣韻 button above and select the pronounciation</span>
                </div>
                <div id="select-concept-group" class="form-group ui-widget">
                    <label for="select-concept">Concept: </label>
                    <input id="select-concept" class="form-control"/>
                </div>
                <div class="form-row">
                <div id="select-synfunc-group" class="form-group ui-widget col-md-6">
                    <label for="select-synfunc">Syntactic function: </label>
                    <input id="select-synfunc" class="form-control"/>
                </div>
                <div id="select-semfeat-group" class="form-group ui-widget col-md-6">
                    <label for="select-semfeat">Semantic feature: </label>
                    <input id="select-semfeat" class="form-control"/>
                </div>
                </div>
                <div id="input-def-group">
                    <label for="select-semfeat">Definition </label>
                    <textarea id="input-def" class="form-control"></textarea>                   
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" onclick="save_to_concept()">Save changes</button>
            </div>
        </div>
    </div>    
    <!-- temp -->
    
</div>    

};


